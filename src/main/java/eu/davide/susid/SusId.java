/*
 * Copyright (c) 2025 Davide Tonin
 * Licensed under the Apache License, Version 2.0: https://opensource.org/license/apache-2-0
 */

package eu.davide.susid;

import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Map;
import java.util.UUID;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * Generates and decodes compact, UUID-like identifiers with embedded timestamp, randomness,
 * type, and secret-based signature.
 */
public class SusId {
    static final int MAX_SECRETS = 256;
    static final int MAX_TYPES = 256;
    private static final int TIMESTAMP_BYTES = 6;
    private static final SecureRandom RAND = new SecureRandom();

    private static final ThreadLocal<MessageDigest> TL_MD =
            ThreadLocal.withInitial(() -> {
                try { return MessageDigest.getInstance("SHA-256"); }
                catch (Exception e) { throw new IllegalStateException(e); }
            });

    private final Map<Integer,String> secrets;
    private final int[] secretIds;
    private final Map<Integer,String> types;
    private final int signatureBytes;
    private final int randomBytes;
    private final int payloadLen;
    private final byte[][] secretBytes;

    /**
     * Result of decoding a SusId token.
     * @param valid     whether the signature is valid
     * @param timestamp milliseconds since epoch
     * @param typeId    type identifier
     * @param typeDesc  description of the type
     * @param secretId  secret identifier used
     * @param signature truncated signature bytes
     */
    public record SusIdInfo(
            boolean valid,
            long timestamp,
            int typeId,
            String typeDesc,
            int secretId,
            byte[] signature
    ) {}


    /**
     * Creates a SusId with a map of secrets and types.
     * @param secrets        mapping of secretId to secret value (max 256 entries)
     * @param types          mapping of typeId to description (max 256 entries)
     * @param signatureBytes number of signature bytes (1–4; reduces randomness accordingly)
     * @throws IllegalArgumentException on invalid sizes or ranges
     */
    public SusId(Map<Integer,String> secrets, Map<Integer,String> types, int signatureBytes) {
            if (secrets.size() > MAX_SECRETS) throw new IllegalArgumentException("Too many secrets");
            if (types.size()   > MAX_TYPES ) throw new IllegalArgumentException("Too many types");
            secrets.keySet().forEach(id -> {
                if (id < 0 || id >= MAX_SECRETS) throw new IllegalArgumentException("Secret id OOB: " + id);
            });
            types.keySet().forEach(id -> {
                if (id < 0 || id >= MAX_TYPES) throw new IllegalArgumentException("Type id OOB: " + id);
            });
            if (signatureBytes < 1 || signatureBytes > 4) throw new IllegalArgumentException("Signature length must be 1–4");

            this.secrets = Map.copyOf(secrets);
            this.types = Map.copyOf(types);
            this.secretIds = secrets.keySet().stream().mapToInt(i -> i).toArray();
            this.signatureBytes = signatureBytes;
            this.randomBytes = 8 - signatureBytes;
            this.payloadLen = TIMESTAMP_BYTES + randomBytes + 2;
            this.secretBytes = new byte[MAX_SECRETS][];
            for (int id : this.secretIds) {
                secretBytes[id] = secrets.get(id).getBytes(UTF_8);
            }
    }

    /**
     * Generates a new SusId with given typeId.
     * @param typeId type identifier
     * @return new UUID identifier
     * @throws IllegalArgumentException if typeId is unrecognized
     */
    public UUID generate(int typeId) {
            if (!types.containsKey(typeId))
                throw new IllegalArgumentException("Unknown type: " + typeId);

            long now = System.currentTimeMillis();
            byte[] id = new byte[16];

            // timestamp
            putLong(id, 0, now, TIMESTAMP_BYTES);

            // randomness
            byte[] rnd = new byte[randomBytes];
            RAND.nextBytes(rnd);
            System.arraycopy(rnd, 0, id, TIMESTAMP_BYTES, randomBytes);

            // type and secret
            id[TIMESTAMP_BYTES + randomBytes]     = (byte) typeId;
            int secretId = secretIds[RAND.nextInt(secretIds.length)];
            id[TIMESTAMP_BYTES + randomBytes + 1] = (byte) secretId;

            // signature
            byte[] sig = sign(id, secretId);
            System.arraycopy(sig, 0, id, payloadLen, signatureBytes);

            // to UUID
            long msb = getLong(id, 0, 8);
            long lsb = getLong(id, 8, 8);
            return new UUID(msb, lsb);
    }

    /**
     * Decodes a SusId UUID into its components and verifies signature.
     * @param uuid identifier previously generated by this class
     * @return SusIdInfo object
     */
    public SusIdInfo decode(UUID uuid) {
            byte[] id = new byte[16];
            putLong(id, 0, uuid.getMostSignificantBits(), 8);
            putLong(id, 8, uuid.getLeastSignificantBits(), 8);

            long ts = getLong(id, 0, TIMESTAMP_BYTES);

            int typeId   = id[TIMESTAMP_BYTES + randomBytes] & 0xFF;
            int secretId = id[TIMESTAMP_BYTES + randomBytes + 1] & 0xFF;

            byte[] storedSig = new byte[signatureBytes];
            System.arraycopy(id, payloadLen, storedSig, 0, signatureBytes);

            String typeDesc = types.getOrDefault(typeId, "Unknown");

            if (!secrets.containsKey(secretId)) {
                return new SusIdInfo(false, ts, typeId, typeDesc, secretId, storedSig);
            }

            byte[] fullSig = sign(id, secretId);

            boolean valid = true;
            for (int i = 0; i < signatureBytes; i++) {
                if (storedSig[i] != fullSig[i]) {
                    valid = false;
                    break;
                }
            }

            return new SusIdInfo(valid, ts, typeId, typeDesc, secretId, storedSig);
    }

    private static void putLong(byte[] dest, int offset, long value, int bytes) {
            for (int i = 0; i < bytes; i++) {
                dest[offset + i] = (byte) (value >>> (8 * (bytes - 1 - i)));
            }
    }

    private static long getLong(byte[] src, int offset, int bytes) {
            long val = 0;
            for (int i = 0; i < bytes; i++) {
                val = (val << 8) | (src[offset + i] & 0xFFL);
            }
            return val;
    }

    private byte[] sign(byte[] data, int secretId) {
            MessageDigest md = TL_MD.get();
            md.reset();
            md.update(secretBytes[secretId]);
            md.update(data, 0, payloadLen);
            return md.digest();
    }
}